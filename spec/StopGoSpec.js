// Generated by CoffeeScript 1.6.2
describe("StopGo", function() {
  it("can queue functions until go", function() {
    var result, stopGo;

    stopGo = new StopGo();
    result = "";
    stopGo.run(function() {
      return result += "a";
    });
    stopGo.run(function() {
      return result += "b";
    });
    expect(result).toBe("");
    stopGo.go();
    return expect(result).toBe("ab");
  });
  it("can be nested multiple times in itself", function() {
    var result, stopGo;

    stopGo = new StopGo();
    result = "";
    stopGo.run(function() {
      result += "a";
      return stopGo.run(function() {
        result += "b";
        return stopGo.run(function() {
          return result += "c";
        });
      });
    });
    expect(result).toBe("");
    stopGo.go();
    return expect(result).toBe("abc");
  });
  it("can be stopped from within a nested scope", function() {
    var result, stopGo;

    stopGo = new StopGo();
    result = "";
    stopGo.run(function() {
      result += "a";
      return stopGo.run(function() {
        result += "b";
        stopGo.stop();
        return stopGo.run(function() {
          return result += "c";
        });
      });
    });
    expect(result).toBe("");
    stopGo.go();
    expect(result).toBe("ab");
    stopGo.go();
    return expect(result).toBe("abc");
  });
  it("gives full access to the queue", function() {
    var fn1, fn2, stopGo;

    stopGo = new StopGo();
    fn1 = function() {};
    fn2 = function() {};
    stopGo.run(fn1).run(fn2);
    expect(stopGo.getQueue()[0]).toBe(fn1);
    expect(stopGo.getQueue()[1]).toBe(fn2);
    stopGo.setQueue(stopGo.getQueue().reverse());
    expect(stopGo.getQueue()[0]).toBe(fn2);
    return expect(stopGo.getQueue()[1]).toBe(fn1);
  });
  it("can remove a function from the queue", function() {
    var fn1, fn2, stopGo;

    stopGo = new StopGo();
    fn1 = function() {};
    fn2 = function() {};
    stopGo.run(fn1).run(fn2);
    expect(stopGo.getQueue().length).toBe(2);
    stopGo.remove(fn1);
    expect(stopGo.getQueue().length).toBe(1);
    return expect(stopGo.getQueue()[0]).toBe(fn2);
  });
  it("can use the short-hand syntax to queue a function", function() {
    var result, stopGo;

    stopGo = new StopGo();
    result = "";
    stopGo(function() {
      return result += "a";
    });
    stopGo(function() {
      return result += "b";
    });
    expect(result).toBe("");
    stopGo.go();
    return expect(result).toBe("ab");
  });
  it("can use short-hand syntax to trigger go", function() {
    var result, stopGo;

    stopGo = new StopGo();
    result = "";
    stopGo(function() {
      return result += "a";
    });
    stopGo(function() {
      return result += "b";
    });
    expect(result).toBe("");
    stopGo(true);
    return expect(result).toBe("ab");
  });
  it("can use short-hand syntax to trigger stop", function() {
    var result, stopGo;

    stopGo = new StopGo();
    result = "";
    stopGo(function() {
      return result += "a";
    });
    stopGo(function() {
      result += "b";
      stopGo(false);
      return stopGo(function() {
        return result += "c";
      });
    });
    expect(result).toBe("");
    stopGo(true);
    expect(result).toBe("ab");
    stopGo(true);
    return expect(result).toBe("abc");
  });
  it("can chain with multiple StopGo instances", function() {
    var result, sg1, sg2;

    sg1 = new StopGo();
    sg2 = new StopGo();
    result = "";
    sg1(function() {
      result += "a";
      return sg2(function() {
        return result += "b";
      });
    });
    expect(result).toBe("");
    sg1(true);
    expect(result).toBe("a");
    sg2(true);
    return expect(result).toBe("ab");
  });
  it("can chain with multiple StopGo instances, in reverse", function() {
    var result, sg1, sg2;

    sg1 = new StopGo();
    sg2 = new StopGo();
    result = "";
    sg1(function() {
      result += "a";
      return sg2(function() {
        return result += "b";
      });
    });
    expect(result).toBe("");
    sg2(true);
    expect(result).toBe("");
    sg1(true);
    return expect(result).toBe("ab");
  });
  return it("can use StopGo.when to chain", function() {
    var result, sg1, sg2;

    sg1 = new StopGo();
    sg2 = new StopGo();
    result = "";
    StopGo.when(sg1, sg2, function() {
      return result = "a";
    });
    expect(result).toBe("");
    sg1(true);
    expect(result).toBe("");
    sg2(true);
    return expect(result).toBe("a");
  });
});
