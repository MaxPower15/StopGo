// Generated by CoffeeScript 1.8.0
describe("StopGo", function() {
  describe('when multiple functions are queued sequentially', function() {
    return it('queues them, then executes them in sequential order on go()', function() {
      var result, stopGo;
      stopGo = new StopGo();
      result = "";
      stopGo.run(function() {
        return result += "a";
      });
      stopGo.run(function() {
        return result += "b";
      });
      expect(result).toBe("");
      stopGo.go();
      return expect(result).toBe("ab");
    });
  });
  describe('when functions that are being flushed queue other functions on the same StopGo', function() {
    return it('executes them in natural execution order', function() {
      var result, stopGo;
      stopGo = new StopGo();
      result = '';
      stopGo.run(function() {
        result += 'a';
        return stopGo.run(function() {
          result += 'b';
          return stopGo.run(function() {
            return result += 'c';
          });
        });
      });
      expect(result).toBe('');
      stopGo.go();
      return expect(result).toBe('abc');
    });
  });
  describe('when one function that\'s being flushed stops the queue', function() {
    return it('finishes executing that function, but halts before flushing the rest of the queue', function() {
      var result, stopGo;
      stopGo = new StopGo();
      result = "";
      stopGo.run(function() {
        result += "a";
        return stopGo.run(function() {
          stopGo.stop();
          result += "b";
          return stopGo.run(function() {
            return result += "c";
          });
        });
      });
      expect(result).toBe("");
      stopGo.go();
      expect(result).toBe("ab");
      stopGo.go();
      return expect(result).toBe("abc");
    });
  });
  describe('getQueue', function() {
    return it('returns all queued functions, in the order that they were queued', function() {
      var fn1, fn2, stopGo;
      stopGo = new StopGo();
      fn1 = function() {};
      fn2 = function() {};
      stopGo.run(fn1).run(fn2);
      expect(stopGo.getQueue()[0]).toBe(fn1);
      expect(stopGo.getQueue()[1]).toBe(fn2);
      stopGo.setQueue(stopGo.getQueue().reverse());
      expect(stopGo.getQueue()[0]).toBe(fn2);
      return expect(stopGo.getQueue()[1]).toBe(fn1);
    });
  });
  describe('synchronize', function() {
    return it('blocks queue execution until done() is called', function() {
      var ran, sg, synchronizing;
      sg = new StopGo();
      synchronizing = false;
      sg.synchronize(function(done) {
        synchronizing = true;
        return setTimeout(done, 10);
      });
      ran = false;
      sg(function() {
        return ran = true;
      });
      sg(true);
      expect(synchronizing).toBe(true);
      expect(ran).toBe(false);
      return waitsFor((function() {
        return ran;
      }), 50);
    });
  });
  describe('remove', function() {
    return it('removes the given function from the queue', function() {
      var fn1, fn2, stopGo;
      stopGo = new StopGo();
      fn1 = function() {};
      fn2 = function() {};
      stopGo.run(fn1).run(fn2);
      expect(stopGo.getQueue().length).toBe(2);
      stopGo.remove(fn1);
      expect(stopGo.getQueue().length).toBe(1);
      return expect(stopGo.getQueue()[0]).toBe(fn2);
    });
  });
  describe('shorthand syntax', function() {
    describe('when passed a function', function() {
      return it('queues the function', function() {
        var result, stopGo;
        stopGo = new StopGo();
        result = '';
        stopGo(function() {
          return result += 'a';
        });
        stopGo(function() {
          return result += 'b';
        });
        expect(result).toBe('');
        stopGo.go();
        return expect(result).toBe('ab');
      });
    });
    describe('when passed true', function() {
      return it('calls go() internally', function() {
        var result, stopGo;
        stopGo = new StopGo();
        result = "";
        stopGo(function() {
          return result += "a";
        });
        stopGo(function() {
          return result += "b";
        });
        expect(result).toBe("");
        stopGo(true);
        return expect(result).toBe("ab");
      });
    });
    return describe('when passed false', function() {
      return it('calls stop() inernally', function() {
        var result, stopGo;
        stopGo = new StopGo();
        result = '';
        stopGo(function() {
          return result += 'a';
        });
        stopGo(function() {
          result += 'b';
          stopGo(false);
          return stopGo(function() {
            return result += 'c';
          });
        });
        expect(result).toBe('');
        stopGo(true);
        expect(result).toBe('ab');
        stopGo(true);
        return expect(result).toBe('abc');
      });
    });
  });
  describe('multiple StopGo instances', function() {
    describe('when the outer StopGo is green before the inner', function() {
      return it('executes the outer StopGo, and waits for the inner before completing', function() {
        var result, sg1, sg2;
        sg1 = new StopGo();
        sg2 = new StopGo();
        result = "";
        sg1(function() {
          result += "a";
          return sg2(function() {
            return result += "b";
          });
        });
        expect(result).toBe("");
        sg1(true);
        expect(result).toBe("a");
        sg2(true);
        return expect(result).toBe("ab");
      });
    });
    return describe('when the inner StopGo is green before the outer', function() {
      return it('delays execution of both queues until the outer StopGo is green', function() {
        var result, sg1, sg2;
        sg1 = new StopGo();
        sg2 = new StopGo();
        result = '';
        sg1(function() {
          result += 'a';
          return sg2(function() {
            return result += 'b';
          });
        });
        expect(result).toBe('');
        sg2(true);
        expect(result).toBe('');
        sg1(true);
        return expect(result).toBe('ab');
      });
    });
  });
  describe('StopGo.when', function() {
    return it('composes a chain of StopGos', function() {
      var result, sg1, sg2;
      sg1 = new StopGo();
      sg2 = new StopGo();
      result = '';
      StopGo.when(sg1, sg2, function() {
        return result = 'a';
      });
      expect(result).toBe('');
      sg1(true);
      expect(result).toBe('');
      sg2(true);
      return expect(result).toBe('a');
    });
  });
  describe('when go() is called from a function that\'s being flushed', function() {
    return it('succeeds without entering an infinite loop', function() {
      var ran, sg;
      sg = new StopGo();
      ran = false;
      sg(function() {
        sg.go();
        return ran = true;
      });
      expect(ran).toBe(false);
      sg.go();
      return expect(ran).toBe(true);
    });
  });
  describe('when stop() and go() are called from a function that\'s being flushed', function() {
    return it('succeeds without entering an infinite loop', function() {
      var ran, sg;
      sg = new StopGo();
      ran = false;
      sg(function() {
        sg.stop();
        sg.go();
        return ran = true;
      });
      expect(ran).toBe(false);
      sg.go();
      return expect(ran).toBe(true);
    });
  });
  return describe('string command syntax', function() {
    describe('when "go" is passed as an argument via shorthand syntax', function() {
      return it('executes go()', function() {
        var sg;
        sg = new StopGo();
        expect(sg()).toBe(false);
        sg('go');
        return expect(sg()).toBe(true);
      });
    });
    return describe('when "remove" is passed as an argument via shorthand syntax', function() {
      return it('executes remove successfully', function() {
        var fn, sg;
        sg = new StopGo();
        fn = function() {
          return console.log('to be removed');
        };
        sg(fn);
        expect(sg('getQueue')[0]).toBe(fn);
        sg('remove', fn);
        return expect(sg('getQueue').length).toBe(0);
      });
    });
  });
});
