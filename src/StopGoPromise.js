// Generated by CoffeeScript 1.6.2
var StopGoPromise,
  __slice = [].slice;

StopGoPromise = (function() {
  function StopGoPromise(continued) {
    this.continued = continued;
    this.finished = new StopGo();
    this._stopGos = [];
    if (this.continued) {
      this.after(this.continued);
    }
  }

  StopGoPromise.prototype.after = function(promise) {
    promise.forwardReject(this);
    this._stopGos.push(promise.finished);
    return this;
  };

  StopGoPromise.prototype.forwardReject = function(to) {
    this.finished(function() {
      var args, state;

      state = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (state === "rejected") {
        return to.reject.apply(to, args);
      }
    });
    return this;
  };

  StopGoPromise.prototype["continue"] = function(fn) {
    StopGo.when.apply(StopGo, [].concat(this._stopGos).concat([this.finished])).run(function() {
      var e;

      try {
        return fn.apply(null, arguments);
      } catch (_error) {
        e = _error;
        if (typeof console !== "undefined" && console !== null) {
          console.log(e.message);
        }
        return typeof console !== "undefined" && console !== null ? console.log(e.stack) : void 0;
      }
    });
    return this;
  };

  StopGoPromise.prototype.then = function(resolvedFn, rejectedFn) {
    this["continue"](function() {
      var args, state;

      state = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (state === "resolved") {
        return typeof resolvedFn === "function" ? resolvedFn.apply(null, args) : void 0;
      } else if (state === "rejected") {
        return typeof rejectedFn === "function" ? rejectedFn.apply(null, args) : void 0;
      } else {
        throw new Error("Invalid finished state, '" + state + "'. No callbacks ran.");
      }
    });
    return new StopGoPromise(this);
  };

  StopGoPromise.prototype.resolve = function() {
    var args,
      _this = this;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    StopGo.when.apply(StopGo, this._stopGos).run(function() {
      var _ref;

      return (_ref = _this.finished).go.apply(_ref, ["resolved"].concat(__slice.call(args)));
    });
    return this;
  };

  StopGoPromise.prototype.reject = function() {
    var args, _ref;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    (_ref = this.finished).go.apply(_ref, ["rejected"].concat(__slice.call(args)));
    return this;
  };

  return StopGoPromise;

})();

StopGoPromise.when = function() {
  var lastPromise, promise, promises, result, _i, _len;

  promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  result = new StopGoPromise().resolve();
  lastPromise = null;
  for (_i = 0, _len = promises.length; _i < _len; _i++) {
    promise = promises[_i];
    if (lastPromise) {
      promise.after(lastPromise);
    }
    lastPromise = promise;
  }
  result.after(lastPromise);
  return result;
};
