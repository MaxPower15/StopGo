// Generated by CoffeeScript 1.8.0
var StopGoPromise,
  __slice = [].slice;

StopGoPromise = (function() {
  function StopGoPromise(continued) {
    this.continued = continued;
    this.finished = new StopGo();
    this._stopGos = [];
    if (this.continued) {
      this.after(this.continued);
    }
  }

  StopGoPromise.prototype.after = function(promise) {
    promise.forwardReject(this);
    this._stopGos.push(promise.finished);
    return this;
  };

  StopGoPromise.prototype.forwardReject = function(to) {
    this.finished(function() {
      var args, state;
      state = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (state === "rejected") {
        return to.reject.apply(to, args);
      }
    });
    return this;
  };

  StopGoPromise.prototype.dependents = function() {
    return [].concat(this._stopGos).concat([this.finished]);
  };

  StopGoPromise.prototype["continue"] = function(fn) {
    StopGo.when.apply(StopGo, this.dependents()).run(function() {
      var e;
      try {
        return fn.apply(null, arguments);
      } catch (_error) {
        e = _error;
        if (typeof console !== "undefined" && console !== null) {
          console.log(e.message);
        }
        return typeof console !== "undefined" && console !== null ? console.log(e.stack) : void 0;
      }
    });
    return this;
  };

  StopGoPromise.prototype.then = function(resolvedFn, rejectedFn) {
    var newPromise;
    if (resolvedFn instanceof StopGoPromise) {
      resolvedFn.after(this);
      newPromise = new StopGoPromise(resolvedFn);
      resolvedFn.then(function() {
        return newPromise.resolve.apply(newPromise, arguments);
      }, function() {
        return newPromise.reject.apply(newPromise, arguments);
      });
      return newPromise;
    } else {
      newPromise = new StopGoPromise(this);
      this["continue"](function() {
        var args, state;
        state = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (state === "resolved") {
          return newPromise.resolve(typeof resolvedFn === "function" ? resolvedFn.apply(null, args) : void 0);
        } else if (state === "rejected") {
          return newPromise.reject(typeof rejectedFn === "function" ? rejectedFn.apply(null, args) : void 0);
        } else {
          throw new Error("Invalid finished state, '" + state + "'. No callbacks ran.");
        }
      });
      return newPromise;
    }
  };

  StopGoPromise.prototype.resolve = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    StopGo.when.apply(StopGo, this._stopGos).run((function(_this) {
      return function() {
        var _ref;
        return (_ref = _this.finished).go.apply(_ref, ["resolved"].concat(__slice.call(args)));
      };
    })(this));
    return this;
  };

  StopGoPromise.prototype.reject = function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    (_ref = this.finished).go.apply(_ref, ["rejected"].concat(__slice.call(args)));
    return this;
  };

  return StopGoPromise;

})();

StopGoPromise.when = function() {
  var lastPromise, promise, promises, result, _i, _len;
  promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  result = new StopGoPromise().resolve();
  lastPromise = null;
  for (_i = 0, _len = promises.length; _i < _len; _i++) {
    promise = promises[_i];
    if (lastPromise) {
      promise.after(lastPromise);
    }
    lastPromise = promise;
  }
  result.after(lastPromise);
  return result;
};
