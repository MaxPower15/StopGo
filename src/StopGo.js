// Generated by CoffeeScript 1.6.2
var StopGo,
  __slice = [].slice;

StopGo = (function() {
  function StopGo() {
    var _this = this;

    this._queue = [];
    this._green = false;
    this._lock = false;
    this.allInOne = function() {
      return _this._allInOne.apply(_this, arguments);
    };
    this.defineMethodsOn(this.allInOne);
    return this.allInOne;
  }

  StopGo.prototype.defineMethodsOn = function(obj) {
    var getType, k, v, _results,
      _this = this;

    getType = {};
    _results = [];
    for (k in this) {
      v = this[k];
      _results.push((function(k, v, klass) {
        if (getType.toString.call(v) === '[object Function]') {
          return obj[k] = function() {
            return klass[k].apply(klass, arguments);
          };
        }
      })(k, v, this));
    }
    return _results;
  };

  StopGo.prototype.flush = function() {
    var args, fn, i, _i, _ref;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!this._green) {
      return this;
    }
    this._lock = true;
    for (i = _i = 0, _ref = this._queue.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (fn = this._queue[i]) {
        if (args.length || !this.goArgs) {
          fn.apply(null, args);
        } else {
          fn.apply(null, this.goArgs);
        }
        this._queue[i] = null;
      }
      if (!this._green) {
        break;
      }
    }
    this.filter(function(fn) {
      return fn != null;
    });
    this._lock = false;
    return this;
  };

  StopGo.prototype.filter = function(cond) {
    var fn;

    this._queue = (function() {
      var _i, _len, _ref, _results;

      _ref = this._queue;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        if (cond(fn)) {
          _results.push(fn);
        }
      }
      return _results;
    }).call(this);
    return this;
  };

  StopGo.prototype.push = function(fn) {
    this._queue.push(fn);
    return this;
  };

  StopGo.prototype.go = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this._green = true;
    this.goArgs = args;
    this.flush.apply(this, args);
    return this;
  };

  StopGo.prototype.stop = function() {
    this._green = false;
    return this;
  };

  StopGo.prototype.run = function() {
    var fn, fns, _i, _len;

    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = fns.length; _i < _len; _i++) {
      fn = fns[_i];
      this.runFn(fn);
    }
    return this;
  };

  StopGo.prototype.runFn = function(fn) {
    if (this._green) {
      if (this._lock) {
        fn();
      } else {
        this.push(fn);
        this.flush();
      }
    } else {
      this.push(fn);
    }
    return this;
  };

  StopGo.prototype.remove = function() {
    var fn, fns, _i, _len;

    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = fns.length; _i < _len; _i++) {
      fn = fns[_i];
      this.removeFn(fn);
    }
    return this;
  };

  StopGo.prototype.removeFn = function(targetFn) {
    this.filter(function(fn) {
      return targetFn !== fn;
    });
    return this;
  };

  StopGo.prototype.setQueue = function(newQueue) {
    this._queue = newQueue;
    return this;
  };

  StopGo.prototype.getQueue = function() {
    return this._queue;
  };

  StopGo.prototype._allInOne = function() {
    var arg, rest;

    arg = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (arg === true) {
      return this.go.apply(this, rest);
    }
    if (arg === false) {
      return this.stop();
    }
    if (arg != null) {
      if (arg instanceof Array) {
        return this.run.apply(this, arg);
      } else {
        return this.run.apply(this, arguments);
      }
    } else {
      return this._green;
    }
  };

  return StopGo;

})();

StopGo.when = function() {
  var lastFn, result, stopGo, stopGos, _fn, _i, _len, _ref;

  stopGos = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  result = new StopGo();
  lastFn = function() {
    return result.go.apply(result, arguments);
  };
  _ref = stopGos.reverse();
  _fn = function(theFn, stopGo) {
    return lastFn = function() {
      return stopGo(function() {
        return theFn.apply(null, arguments);
      });
    };
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    stopGo = _ref[_i];
    _fn(lastFn, stopGo);
  }
  lastFn();
  return result;
};
